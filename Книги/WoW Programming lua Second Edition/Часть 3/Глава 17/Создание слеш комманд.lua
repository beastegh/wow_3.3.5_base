"📘 Создание слэш-команд"

  Игроки в World of Warcraft ежедневно используют слэш-команды. Будь то /ignore Ikeelyou или поспешное /gquit после ниндзя-лутания Кель'Таса при первом убийстве в гильдии — всё это примеры слэш-команд.

  Как автор аддонов, вы часто обнаружите, что добавление слэш-команд — это простой и полезный способ заставить аддон выполнять действия или открывать настройки. Как правило, реализовать систему слэш-команд гораздо быстрее, чем полноценный графический интерфейс конфигурации.

  Создание базовых слэш-команд

  WoW предоставляет довольно простой способ реализации слэш-команд. Требуются два основных элемента: набор глобальных переменных для самих команд и функция-обработчик в глобальной таблице. Вот простой пример:

    SLASH_FANCYPRINT1 = "/fancyprint"

    SlashCmdList["FANCYPRINT"] = function(msg)
      print("|cff11ff11" .. "Printed:|r " .. msg)
    end

  После выполнения этого кода введите в окно чата:
    /fancyprint This is my first slash command!

  Вы должны увидеть сообщение в чате: "This is my first slash command!", с зелёным заголовком "Printed".

  Теперь посмотрим, как это работает. WoW хранит все обработчики слэш-команд в таблице SlashCmdList. Индексация этой таблицы осуществляется произвольными строками, которые выбирает автор аддона. Эти индексы используются для создания имён глобальных переменных в следующем формате:

    SLASH_INDEXn

  В предыдущем примере индекс — это FANCYPRINT, а глобальная переменная — SLASH_FANCYPRINT1. Когда вы ввели слэш-команду, WoW начал просматривать все записи в SlashCmdList. Для каждой записи система начинала счёт с 1 и проверяла соответствующие глобальные переменные. Как только она нашла SLASH_FANCYPRINT1, совпавшую с введённой командой, была вызвана соответствующая функция из SlashCmdList, и ей была передана вся остальная строка после команды.

  Такая схема обеспечивает отличную гибкость. 
    🔸Например, введите:
        SLASH_FANCYPRINT2 = "/fp"

  А затем попробуйте использовать:
    /fp I created a slash command alias

  И вы снова увидите вывод с этим текстом. Как видите, увеличение номера переменной позволяет создать несколько синонимов для одной и той же команды. Это также удобно для локализации.

  Итак, короткий чеклист по созданию слэш-команд:
    🔹 Создайте функцию-обработчик, принимающую один строковый параметр.
    🔹 Выберите уникальное имя индекса (желательно с именем аддона, чтобы избежать конфликтов) и добавьте обработчик в SlashCmdList.
    🔹 Создайте одну или несколько глобальных переменных SLASH_INDEXn, содержащих сами слэш-команды.

  Как видите, создать слэш-команду — это просто. Сложнее — сделать что-то полезное с переданным текстом. Всё, что пользователь вводит после команды, передаётся обработчику как одна строка. Чтобы работать с этим, придётся выполнять простую разборку строки (парсинг). Оставшаяся часть главы будет посвящена именно таким техникам.

  🔥"ПРЕДУПРЕЖДЕНИЕ"
    Система слэш-команд сохраняет кэш команд, которые вы используете в течение игровой сессии, чтобы уменьшить нагрузку на производительность от макросов. Это также означает, что если вы попытаетесь перезаписать обработчик в SlashCmdList без перезагрузки интерфейса, вам нужно обновить кэш. Например, если вы использовали созданную вами команду в WowLua, затем изменили код и снова выполнили скрипт, WoW попытается использовать старую функцию при следующем вызове команды.

    Вы можете вручную выполнить следующий код или добавить его в конец скрипта:
      wipe(hash_SlashCmdList)

    Это необходимо только в случае, если вы изменяете обработчик уже определённой слэш-команды. При первом создании новой команды этого делать не нужно.

    Подробности работы кэша выходят за рамки этой главы, но общая техника описана в Приложении A. Вы также можете сами изучить код обработки команд в файле:
      FrameXML\ChatFrame.lua.

"📘 Токенизация строк"

  Токенизация — это процесс деления строки на более мелкие части, называемые токенами, по определённым правилам. Один из самых простых способов сделать это в WoW — использовать специфичную для игры функцию string.split (или её псевдоним strsplit). Эта функция разбивает строку по заданному разделителю. Например:

    string.split(" ", "1 + 3 * 5")

  Разделяет строку по пробелам и возвращает токены: "1", "+", "3", "*", "5".

  Как видно из примера, с помощью этой техники можно создать простой калькулятор. Откройте WowLua или создайте новый аддон с Lua-файлом. Чтобы упростить реализацию, калькулятор будет распознавать только четыре оператора: сложение (+), вычитание (-), умножение (*) и деление (/). Кроме того, порядок операций учитываться не будет. То есть выражение 1 + 3 * 5 вернёт 20, а не 16.

  Сами операции будут храниться в таблице, индексируемой символами операторов:

    local operators = {
      ["+"] = function(a, b) return a + b end,
      ["-"] = function(a, b) return a - b end,
      ["*"] = function(a, b) return a * b end,
      ["/"] = function(a, b) return a / b end
    }

  Каждая функция принимает два числа и возвращает результат. Поскольку операции выполняются строго в порядке появления, основная функция вычисления просто проходит по токенам, возвращённым string.split:

    local function calculate(number1, ...)
      for i = 1, select("#", ...), 2 do
        local operator, number2 = select(i, ...)
        number1 = operators[operator](number1, number2)
      end
      
      return number1
    end

  🔹 Первое число сохраняется в переменную number1. 
  🔹 Затем цикл извлекает первый оператор и следующее число, вызывает соответствующую функцию и присваивает результат обратно number1.
  🔹 Далее цикл повторяется для следующих пары оператор/число, пока не достигнет конца строки.

  Осталось только создать слэш-команду, которая будет разбивать сообщение на токены и выводить результат вычисления:

    SLASH_SIMPLECALC1 = "/calculate"
    SLASH_SIMPLECALC2 = "/calc"
    SlashCmdList["SIMPLECALC"] = function(message)
      print(calculate(string.split(" ", message)))
    end

  Запустите скрипт или загрузите аддон, и вы сможете использовать команды как показано ниже:

      /calculate 1 + 3 * 5
    > 20

      /calc 3 * 2 + 4 / 5.5
    > 1.8181818181818

      /calc 4
    > 4

  Конечно, такой калькулятор работает, но у него есть свои ограничения. Поскольку строка разделяется по каждому пробелу, даже лишний пробел создаёт пустую строку между токенами. 
  Например:

    /calculate 3 + 4
  > Ошибка: attempt to call field '?' (a nil value)

  Из-за лишнего пробела строка разбивается на токены: "3", "", "+", "4". Функция calculate пытается найти операцию по пустой строке, что приводит к ошибке.

  Аналогично, если пробелы отсутствуют:

    /calc 3+4 * 5
  > Ошибка: attempt to perform arithmetic on local 'a' (a string value)

  В этом случае строка разбивается на "3+4", "*", "5", и "3+4" интерпретируется как число, что вызывает ошибку при арифметической операции.

  Хотя эти ограничения влияют на удобство использования калькулятора, разделение по пробелам по-прежнему подходит для многих задач. Позже в этой главе вы снова используете эту технику — но в гораздо более мощной форме. А пока давайте немного упростим синтаксис калькулятора.

"📘 Токенизация с помощью шаблонов (паттернов)"

  Разбор строк — это тема, которой можно посвятить целую книгу. Существует множество техник, и выбор зависит от сложности правил. Некоторые языки программирования были созданы исключительно для описания синтаксиса других языков.

  Хотя полноценное объяснение выходит за рамки этой книги, мы можем показать несколько приёмов, которые предоставляет Lua.

  В главе 6 вы уже видели паттерны Lua, позволяющие находить определённые сочетания символов в строке. Теперь вы будете использовать их, чтобы распознавать отдельные компоненты команд калькулятора.
"📘 Настройка шаблонов (паттернов)"

  Сначала нужно более точно определить синтаксис команд. Формат для этих команд выглядит следующим образом:

    number [ operator number [ operator number [ ... ] ]

  Это задаёт общую структуру, которую следует соблюдать при разборе строки. Позже вы разработаете функции парсинга, следуя именно этому шаблону.

  Теперь нужно подробнее описать формат каждого компонента. Операторы — это просто один из четырёх символов операторов. Числа — немного сложнее:

  [знак][цифры][десятичная точка]цифры

  Исходя из этого, можно легко составить шаблоны для каждого компонента. Чтобы код оставался гибким, не нужно создавать специальный шаблон для операторов. Вместо этого вы будете просто искать один любой символ и проверять, есть ли он в списке допустимых операторов. Это означает, что шаблон для оператора — просто точка (.) — символ "любой один".

  В таблице ниже показаны подшаблоны, из которых формируется итоговый шаблон: [+-]?%d*%.?%d+ (см. главу 6 для деталей).

  КОМПОНЕНТ | ШАБЛОН
    sign (необязательный)    — [+-]?
    digits (необязательные)  — %d*
    decimal (необязательная) — %.?
    digits (обязательные)    — %d+

  Теперь добавьте следующий код выше всех существующих функций:

    local NUMBER_PATTERN = "^%s*([+-]?%d*%.?%d+)"
    local OPERATOR_PATTERN = "^%s*(.)"
    local END_PATTERN = "^%s*$"

  Так как калькулятор будет принимать любое количество пробелов между числами и операторами, вы заключаете основной шаблон в круглые скобки (для захвата) и добавляете перед ним проверку на пробелы: %s*. Обратите внимание, что шаблон начинается с символа начала строки (^) — он указывает, что соответствие должно начинаться с самого начала оставшейся строки.

  Если не использовать символ ^, шаблон может пропустить недопустимый синтаксис, продолжая поиск валидной части дальше по строке.
  Например:

    /calculate 5 + should error here 5
  > 10

  После обработки плюса, код попытается применить шаблон числа к строке "should error here 5". Без проверки начала строки (^), Lua найдёт соответствие в конце — " 5", полностью проигнорировав недопустимые слова.

  Также вы могли заметить, что был добавлен шаблон END_PATTERN — он используется для обработки возможных пробелов в конце команды.

"📘 Подготовка к токенизации"

  Один из полезных побочных эффектов глубокого разбора строки — это простота в обнаружении и обработке ошибок. В нашем калькуляторе возможны два типа ошибок: отсутствующее/некорректное число и нераспознанный оператор. 
  Добавьте следующие строки ошибок сразу после паттернов, которые вы уже создали:

    local NUMBER_ERROR = "No valid number at position %d"
    local OPERATOR_ERROR = "Unrecognized operator at position %d: '%s'"

  Ошибки отслеживаются через флаг errorState, который устанавливается с помощью специальной функции. 
  Добавьте следующий код непосредственно перед функцией calculate:

    local errorState = false
    
    local function reportError(message)
    print(message)
    errorState = true
    end
    
  Теперь отредактируйте функцию calculate, чтобы она выглядела следующим образом:

    local function calculate(number1, ...)
      if errorState then
        return
      end

      for i = 1, select("#", ...), 2 do
        local operatorFunction, number2 = select(i, ...)
        number1 = operatorFunction(number1, number2)
      end

      return number1
    end

  Если errorState уже установлен, функция просто выходит и ничего не делает.

  Последнее изменение, которое нужно внести перед тем как перейти к самой токенизации — это сброс флага ошибок перед вызовом calculate и замена вызова string.split на tokenize, которую вы скоро напишете:

  SlashCmdList["SIMPLECALC"] = function(message)
    errorState = false
    print(calculate(tokenize(message)))
  end

"📘 Разбор формулы"

  Формулы для калькулятора всегда начинаются с числа, а далее могут содержать произвольное количество пар "оператор + число". Основная функция tokenize сначала извлекает первое число, а затем вызывает рекурсивную функцию getpairs, чтобы... ну... получить оставшиеся пары.

  Добавьте функцию tokenize перед обработчиком SlashCmdList, используя следующий код:

    local function tokenize(message)
      local _, finish, number = message:find(NUMBER_PATTERN)

      if not number then
        reportError(NUMBER_ERROR:format(1))
        return
      end

  Первая строка использует string.find, чтобы найти первое число в формуле (напоминаем, каждая строка в Lua имеет таблицу string как метатаблицу). Если число не найдено, вызывается reportError, и выполнение прекращается.

  Завершите функцию следующим кодом:

    finish = finish + 1

    if message:match(END_PATTERN, finish) == "" then
      return number
    else
      return number, getpairs(message, finish)
    end
  end

  Переменная finish содержит позицию последнего символа найденного числа. Например, в формуле "102 + 5" значение finish будет 3, что соответствует цифре 2 в 102. Далее мы увеличиваем значение finish на 1, чтобы перейти к оставшейся части строки.

  Затем мы проверяем остаток строки на соответствие шаблону END_PATTERN, начиная с новой позиции. Если остаток пуст (то есть строка завершилась), возвращается только число. В противном случае — возвращается число и результат вызова getpairs, которая разберёт остаток строки.
  Теперь создайте функцию getpairs выше tokenize:

  local function getpairs(message, start)
    local _, operatorFinish, operator = message:find(OPERATOR_PATTERN, start)
    local operatorFunction = operators[operator]

    if not operatorFunction then
      reportError(OPERATOR_ERROR:format(start, operator))
    return
  end

  Как видно, мы проверяем, существует ли такой оператор. Если нет — вызывается сообщение об ошибке.
  Теперь ищем следующее число — начиная сразу после оператора:

    operatorFinish = operatorFinish + 1
    local _, numberFinish, number = message:find(NUMBER_PATTERN, operatorFinish)

    if not number then
      reportError(NUMBER_ERROR:format(operatorFinish))
      return
    end

  Завершите функцию аналогично tokenize:

    numberFinish = numberFinish + 1
    if message:match(END_PATTERN, numberFinish) then
      return operatorFunction, number
    else
      return operatorFunction, number, getpairs(message, numberFinish)
    end
  end

  После перезагрузки интерфейса вы увидите, что прежние ошибки больше не возникают, а настоящие ошибки отображаются с понятными сообщениями:

    /calculate 3 + 4
  > 7

    /calc 3+4 * 5
  > 35

    /calc 3+ 4 +
  > No valid number at position 7

    /calc 3 + 4 & 9
  > Unrecognized operator at position 7: '&'

"📘 Использование таблицы команд"

  Некоторые аддоны предоставляют одну слэш-команду, которая включает в себя несколько вложенных подкоманд. Например, чтобы открыть интерфейс аддона Omen, используется команда:

    /omen gui show

  Такую функциональность легко реализовать при помощи относительно простой системы парсинга, которая использует таблицу, представляющую иерархию команд. Разработанный здесь парсер использует таблицу, в которой:

    🔹 Ключами являются названия команд;
    🔹 Значения могут быть:
      🔹 строкой — которая просто выводится,
      🔹 функцией — которая вызывается с оставшейся частью команды как аргумент,
      🔹 или другой таблицей — которая обрабатывается дальше, как вложенный уровень команд.

  Если нужная команда не найдена, парсер проверяет наличие ключа "help" и обрабатывает его, как описано выше.
  Создайте новый аддон с одним Lua-файлом и добавьте следующую таблицу команд:

    local testCommandTable = {
      ["gui"] = {
        ["width"] = function(width)
          print("Setting width to", width)
        end,
        ["height"] = function(height)
          print("Setting height to", height)
        end,
        ["show"] = function()
          print("Showing")
        end,
        ["hide"] = function()
          print("Hiding")
        end,
        ["help"] = "GUI commands: width <width>, height <height>, show, hide"
      },
      ["data"] = {
        ["load"] = function(profile)
          print("Loading profile:", profile)
        end,
        ["save"] = function(profile)
          print("Saving profile:", profile)
        end,
        ["reset"] = function()
          print("Resetting to default")
        end,
        ["help"] = "Data commands: load <profile>, save <profile>, reset"
      },
      ["help"] = "CommandTable commands: gui, data"
    }

  Как видите, это очень лаконичный способ описать широкий спектр действий — особенно после того, как движок будет готов.
  Теперь создайте функцию обработки команд и начните с этого кода:

    local function DispatchCommand(message, commandTable)
      local command, parameters = string.split(" ", message, 2)
      local entry = commandTable[command:lower()]
      local which = type(entry)

  Первая строка разбивает строку message по первому пробелу. Обратите внимание на дополнительный аргумент 2, который указывает, что string.split должен вернуть максимум две строки — это ограничивает количество разбиений.

  Следующая строка извлекает нужный элемент из переданной таблицы команд, а затем определяется его тип. Остальная часть функции фактически реализует описанное выше поведение:

      if which == "function" then
        entry(parameters)
      elseif which == "table" then
        DispatchCommand(parameters or "", entry)
      elseif which == "string" then
        print(entry)
      elseif message ~= "help" then
        DispatchCommand("help", commandTable)
      end
    end

  Осталось привязать всё это к слэш-команде:

    SLASH_COMMANDTABLE1 = "/commandtable"
    SLASH_COMMANDTABLE2 = "/cmdtbl"
    SlashCmdList["COMMANDTABLE"] = function(message)
      DispatchCommand(message, testCommandTable)
    end

  Всего 21 строка кода — и у вас уже готов мощный обработчик слэш-команд, использующий простую таблицу для конфигурации.

  Примеры вывода:

      /cmdtbl gui show
    > Showing

      /commandtable data
    > Data commands: load <profile>, save <profile>, reset

      /cmdtbl GUI Width 13
    > Setting width to 13

"📘 Итоги"

  В этой главе вы узнали основы создания слэш-команд и научились запускать простейшие команды. Вы также познакомились с рядом приёмов и хитростей, позволяющих сделать код более гибким и чистым.

  Слэш-команды — это не самая эффектная часть аддона, и в некоторых кругах к ним относятся с пренебрежением, но на деле они мощные, гибкие и, при правильной реализации, элегантные.

  Одним из сильнейших преимуществ слэш-команд по сравнению с графическими интерфейсами настройки является то, что слэш-команды можно использовать в макросах, что позволяет игрокам изменять параметры "на лету", привязывая такие действия к кнопкам на панели способностей.